'use strict';
/**
 * This client was automatically generated by RudderTyper. ** Do Not Edit **
 */
var __assign =
  (this && this.__assign) ||
  function () {
    __assign =
      Object.assign ||
      function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
    return __assign.apply(this, arguments);
  };
Object.defineProperty(exports, '__esModule', { value: true });
exports.RudderTyperAnalytics = void 0;
exports.setRudderTyperOptions = setRudderTyperOptions;
exports.sampleEvent1 = sampleEvent1;
exports.page = page;
exports.screen = screen;
exports.identify = identify;
exports.group = group;
var missingAnalyticsNodeError = new Error(
  "You must set an analytics-node instance:\n\n>\tconst RudderAnalytics = require('@rudderstack/rudder-sdk-node');\n>\tconst { setRudderTyperOptions } = require('./analytics')\n>\n>\tconst analytics = new RudderAnalytics(WRITE_KEY, DATA_PLANE_URL/v1/batch)\n>\tsetRudderTyperOptions({\n>\t\tanalytics: analytics,\n>\t})\n\nFor more information on analytics-node, see: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#installing-the-rudderstack-node-js-sdk\n",
);
var analytics = function () {
  throw missingAnalyticsNodeError;
};
/**
 * Updates the run-time configuration of this RudderTyper client.
 * This function must be called with a configured analytics-node instance before firing
 * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
 *
 * @param {RudderTyperOptions} options - the options to upsert
 *
 * @typedef {Object} RudderTyperOptions
 * @property {Rudder.AnalyticsNode} analytics - Underlying analytics instance where analytics
 * 		calls are forwarded on to.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
function setRudderTyperOptions(options) {
  analytics = options.analytics
    ? function () {
        return options.analytics;
      }
    : analytics;
}
/**
 * Helper to attach metadata on RudderTyper to outbound requests.
 * This is used for attribution and debugging by the RudderStack team.
 */
function withRudderTyperContext(message) {
  return __assign(__assign({}, message), {
    context: __assign(__assign({}, message.context || {}), {
      ruddertyper: {
        sdk: 'analytics-node',
        language: 'javascript',
        rudderTyperVersion: '1.2.0',
        trackingPlanId: 'tp_2kKI0i514th5OEuYi5AdsRwNlXC',
        trackingPlanVersion: 3,
      },
    }),
  });
}
/**
 * A message payload for an analytics-node `.track()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#track
 *
 * @typedef TrackMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {PropertiesType} [properties] - A dictionary of properties for the event.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
/**
 * A message payload for an analytics-node `.page()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#page
 * @typedef PageMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {string} name - The name of the page viewed.
 * @property {PropertiesType} [properties] - A dictionary of properties for the event.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
/**
 * A message payload for an analytics-node `.screen()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#screen
 * @typedef ScreenMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {string} name - The name of the screen viewed.
 * @property {PropertiesType} [properties] - A dictionary of properties for the event.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
/**
 * A message payload for an analytics-node `.identify()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#identify
 * @typedef IdentifyMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {PropertiesType} [traits] - A dictionary of traits for the user.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
/**
 * A message payload for an analytics-node `.group()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#group
 * @typedef GroupMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {string} groupId - The ID for this group in your database.
 * @property {PropertiesType} [traits] - A dictionary of traits for the group.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
/**
 * @typedef SampleEvent1
 * @property {any | null} [Sample property 1] - Sample property 1
 */
/**
 * @typedef Screen
 * @property {any | null} [Sample property 1] -
 */
/**
 * @typedef Page
 * @property {any | null} [Sample property 1] -
 */
/**
 * @typedef Group
 * @property {any | null} [Sample property 1] -
 */
/**
 * @typedef Identify
 * @property {any | null} [Sample property 1] -
 */
/**
 * Sample event 1
 *
 * @param {TrackMessage<SampleEvent1>} message - The analytics properties that will be sent to RudderStack.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
function sampleEvent1(trackMessage, callback) {
  var message = withRudderTyperContext(
    __assign(__assign({}, trackMessage), { event: 'Sample event 1' }),
  );
  var a = analytics();
  if (a) {
    a.track(message, callback);
  } else {
    throw missingAnalyticsNodeError;
  }
}
/**
 * Sample Page event
 *
 * @param {PageMessage<Page>} message - The analytics properties that will be sent to RudderStack.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
function page(pageMessage, callback) {
  var message = withRudderTyperContext(__assign({ name: '' }, pageMessage));
  var a = analytics();
  if (a) {
    a.page(message, callback);
  } else {
    throw missingAnalyticsNodeError;
  }
}
/**
 * Sample Screen event
 *
 * @param {ScreenMessage<Screen>} message - The analytics properties that will be sent to RudderStack.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
function screen(screenMessage, callback) {
  var message = withRudderTyperContext(__assign({ name: '' }, screenMessage));
  var a = analytics();
  if (a) {
    a.screen(message, callback);
  } else {
    throw missingAnalyticsNodeError;
  }
}
/**
 * Sample Identify event
 *
 * @param {IdentifyMessage<Identify>} message - The analytics properties that will be sent to RudderStack.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
function identify(identifyMessage, callback) {
  var message = withRudderTyperContext(__assign({}, identifyMessage));
  var a = analytics();
  if (a) {
    a.identify(message, callback);
  } else {
    throw missingAnalyticsNodeError;
  }
}
/**
 * Sample Group event
 *
 * @param {GroupMessage<Group>} message - The analytics properties that will be sent to RudderStack.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
function group(groupMessage, callback) {
  var message = withRudderTyperContext(__assign({ groupId: '' }, groupMessage));
  var a = analytics();
  if (a) {
    a.group(message, callback);
  } else {
    throw missingAnalyticsNodeError;
  }
}
var clientAPI = {
  /**
   * Updates the run-time configuration of this RudderTyper client.
   * This function must be called with a configured analytics-node instance before firing
   * any analytics calls, or else a `missingAnalyticsNodeError` error will be thrown.
   *
   * @param {RudderTyperOptions} options - the options to upsert
   *
   * @typedef {Object} RudderTyperOptions
   * @property {Rudder.AnalyticsNode} analytics - Underlying analytics instance where analytics
   * 		calls are forwarded on to.
   * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
   * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
   * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
   * 		will be logged to stderr.
   */
  setRudderTyperOptions: setRudderTyperOptions,
  /**
   * Sample event 1
   *
   * @param {TrackMessage<SampleEvent1>} message - The analytics properties that will be sent to RudderStack.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  sampleEvent1: sampleEvent1,
  /**
   * Sample Page event
   *
   * @param {PageMessage<Page>} message - The analytics properties that will be sent to RudderStack.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  page: page,
  /**
   * Sample Screen event
   *
   * @param {ScreenMessage<Screen>} message - The analytics properties that will be sent to RudderStack.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  screen: screen,
  /**
   * Sample Identify event
   *
   * @param {IdentifyMessage<Identify>} message - The analytics properties that will be sent to RudderStack.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  identify: identify,
  /**
   * Sample Group event
   *
   * @param {GroupMessage<Group>} message - The analytics properties that will be sent to RudderStack.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  group: group,
};
exports.RudderTyperAnalytics = new Proxy(clientAPI, {
  get: function (target, method) {
    if (typeof method === 'string' && Object.keys(target).includes(method)) {
      return target[method];
    }
    return function () {
      var a = analytics();
      if (a) {
        a.track(
          withRudderTyperContext({
            event: 'Unknown Analytics Call Fired',
            properties: {
              method: [method],
            },
            userId: 'ruddertyper',
          }),
        );
      }
    };
  },
});
