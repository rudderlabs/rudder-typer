/**
 * This client was automatically generated by RudderTyper. ** Do Not Edit **
 */

import type {
  RudderAnalytics,
  RudderAnalyticsPreloader,
  ApiOptions,
  ApiObject,
} from '@rudderstack/analytics-js';
/**
 * The analytics instance should be available via window.rudderanalytics.
 * You can install it by following instructions at: https://www.rudderstack.com/docs/sources/event-streams/sdks/rudderstack-javascript-sdk/installation/
 */
declare global {
  interface Window {
    rudderanalytics: RudderAnalytics | RudderAnalyticsPreloader | undefined;
  }
}

type apiCallback = (data?: any) => void;

export interface SampleEvent1 {
  /**
   * Sample property 1
   */
  'Sample property 1'?: any | null;
}

export interface Page {
  'Sample property 1'?: any | null;
}

export interface Group {
  'Sample property 1'?: any | null;
}

export interface Identify {
  'Sample property 1'?: any | null;
}

export type ViolationHandler = (message: Record<string, any>, violations: any[]) => void;

let analytics: () => any | undefined = () => {
  return window.rudderanalytics;
};

/** Options to customize the runtime behavior of a RudderTyper client. */
export interface RudderTyperOptions {
  /**
   * Underlying analytics instance where analytics calls are forwarded on to.
   * Defaults to window.rudderanalytics.
   */
  analytics?: any;
  /**
   * Handler fired when if an event does not match its spec. This handler
   * does not fire in production mode, because it requires inlining the full
   * JSON Schema spec for each event in your Tracking Plan.
   *
   * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
   * if a message does not match the spec. Otherwise, errors will be logged to stderr.
   */
  onViolation?: ViolationHandler;
}

/**
 * Updates the run-time configuration of this RudderTyper client.
 *
 * @param {RudderTyperOptions} options - the options to upsert
 *
 * @typedef {Object} RudderTyperOptions
 * @property {Rudder.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
 * 		calls are forwarded on to. Defaults to window.analytics.
 * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
 * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
 * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
 * 		will be logged to stderr.
 */
export function setRudderTyperOptions(options: RudderTyperOptions) {
  analytics = options.analytics ? () => options.analytics || window.rudderanalytics : analytics;
}

/**
 * Helper to attach metadata on RudderTyper to outbound requests.
 * This is used for attribution and debugging by the RudderStack team.
 */
function withRudderTyperContext(message: ApiOptions = {}): ApiOptions {
  return {
    ...message,
    context: {
      ...((message.context as ApiObject) || {}),
      ruddertyper: {
        sdk: 'analytics.js',
        language: 'typescript',
        rudderTyperVersion: '1.2.0',
        trackingPlanId: 'tp_2kKI0i514th5OEuYi5AdsRwNlXC',
        trackingPlanVersion: 3,
      },
    },
  };
}

/**
 * @typedef SampleEvent1
 * @property {any | null} [Sample property 1] - Sample property 1
 */
/**
 * @typedef Page
 * @property {any | null} [Sample property 1] -
 */
/**
 * @typedef Group
 * @property {any | null} [Sample property 1] -
 */
/**
 * @typedef Identify
 * @property {any | null} [Sample property 1] -
 */

/**
 * Sample event 1
 *
 * @param {SampleEvent1} [props] - The analytics properties that will be sent to RudderStack.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
export function sampleEvent1(
  props?: SampleEvent1,
  options?: ApiOptions,
  callback?: apiCallback,
): void {
  const a = analytics();

  if (a) {
    a.track('Sample event 1', props || {}, withRudderTyperContext(options), callback);
  }
}

/**
 * Sample Page event
 *
 * @param {string} [category] - The category of the page.
 * @param {string} [name] - The name of the page.
 * @param {Page} [props] - The analytics properties that will be sent to RudderStack.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
export function page(
  category: string,
  name: string,
  props?: Page,
  options?: ApiOptions,
  callback?: apiCallback,
): void;
export function page(
  name: string,
  props?: Page,
  options?: ApiOptions,
  callback?: apiCallback,
): void;
export function page(props?: Page, options?: ApiOptions, callback?: apiCallback): void;
export function page(
  categoryOrProps?: string | Page,
  nameOrPropsOrOptions?: string | Page | ApiOptions,
  propsOrOptionsOrCallback?: Page | ApiOptions | apiCallback,
  optionsOrCallback?: ApiOptions | apiCallback,
  callback?: apiCallback,
): void {
  const a = analytics();

  if (a) {
    if (typeof categoryOrProps === 'string' && typeof nameOrPropsOrOptions === 'string') {
      // Overload (category: string, name: string, props?: Page, options?: ApiOptions, callback?: apiCallback)
      a.page(
        categoryOrProps,
        'page',
        (propsOrOptionsOrCallback as Page) || {},
        withRudderTyperContext(optionsOrCallback as ApiOptions),
        callback,
      );
    } else if (typeof categoryOrProps === 'string') {
      // Overload (name: string, props?: Page, options?: ApiOptions, callback?: apiCallback)
      a.page(
        'page',
        (nameOrPropsOrOptions as Page) || {},
        withRudderTyperContext(propsOrOptionsOrCallback as ApiOptions),
        optionsOrCallback as apiCallback,
      );
    } else {
      // Overload (props?: Page, options?: ApiOptions, callback?: apiCallback)
      a.page(
        categoryOrProps || {},
        withRudderTyperContext(nameOrPropsOrOptions as ApiOptions),
        propsOrOptionsOrCallback as apiCallback,
      );
    }
  }
}

/**
 * Sample Identify event
 *
 * @param {string} [userId] - The user ID of the user.
 * @param {Identify} [traits] - The analytics traits that will be sent to RudderStack.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
export function identify(
  userId: string,
  traits?: Identify,
  options?: ApiOptions,
  callback?: apiCallback,
): void;
export function identify(traits?: Identify, options?: ApiOptions, callback?: apiCallback): void;
export function identify(
  userIdOrTraits?: string | Identify,
  traitsOrOptions?: Identify | ApiOptions,
  optionsOrCallback?: ApiOptions | apiCallback,
  callback?: apiCallback,
): void {
  const a = analytics();

  if (a) {
    const userId = typeof userIdOrTraits === 'string' ? userIdOrTraits : undefined;
    const traits =
      typeof userIdOrTraits === 'string'
        ? (traitsOrOptions as Identify)
        : (userIdOrTraits as Identify);
    const options =
      typeof userIdOrTraits === 'string'
        ? (optionsOrCallback as ApiOptions)
        : (traitsOrOptions as ApiOptions);
    const cb = typeof userIdOrTraits === 'string' ? callback : (optionsOrCallback as apiCallback);

    a.identify(userId, traits || {}, withRudderTyperContext(options), cb);
  }
}

/**
 * Sample Group event
 *
 * @param {string} [groupId] - The group ID of the group.
 * @param {Group} [traits] - The analytics traits that will be sent to RudderStack.
 * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
 * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
 */
export function group(
  groupId: string,
  traits?: Group,
  options?: ApiOptions,
  callback?: apiCallback,
): void;
export function group(traits?: Group, options?: ApiOptions, callback?: apiCallback): void;
export function group(
  groupIdOrTraits?: string | Group,
  traitsOrOptions?: Group | ApiOptions,
  optionsOrCallback?: ApiOptions | apiCallback,
  callback?: apiCallback,
): void {
  const a = analytics();

  if (a) {
    if (typeof groupIdOrTraits === 'string') {
      const groupId = groupIdOrTraits;
      const traits = (traitsOrOptions as Group) || {};
      const options = optionsOrCallback as ApiOptions;
      a.group(groupId, traits, withRudderTyperContext(options), callback);
    } else {
      const traits = (groupIdOrTraits as Group) || {};
      const options = traitsOrOptions as ApiOptions;
      const cb = optionsOrCallback as apiCallback;
      a.group(traits, withRudderTyperContext(options), cb);
    }
  }
}

const clientAPI = {
  /**
   * Updates the run-time configuration of this RudderTyper client.
   *
   * @param {RudderTyperOptions} options - the options to upsert
   *
   * @typedef {Object} RudderTyperOptions
   * @property {Rudder.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
   * 		calls are forwarded on to. Defaults to window.analytics.
   * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
   * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
   * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
   * 		will be logged to stderr.
   */
  setRudderTyperOptions,
  /**
   * Sample event 1
   *
   * @param {SampleEvent1} [props] - The analytics properties that will be sent to RudderStack.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  sampleEvent1,
  /**
   * Sample Page event
   *
   * @param {string} [category] - The category of the page.
   * @param {string} [name] - The name of the page.
   * @param {Page} [props] - The analytics properties that will be sent to RudderStack.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  page,
  /**
   * Sample Identify event
   *
   * @param {string} [userId] - The user ID of the user.
   * @param {Identify} [traits] - The analytics traits that will be sent to RudderStack.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  identify,
  /**
   * Sample Group event
   *
   * @param {string} [groupId] - The group ID of the group.
   * @param {Group} [traits] - The analytics traits that will be sent to RudderStack.
   * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
   * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
   */
  group,
};

export const RudderTyperAnalytics = new Proxy<typeof clientAPI>(clientAPI, {
  get(target, method) {
    if (typeof method === 'string' && Object.keys(target).includes(method)) {
      return target[method as keyof typeof clientAPI];
    }

    return () => {
      const a = analytics();
      if (a) {
        a.track(
          'Unknown Analytics Call Fired',
          {
            method,
          },
          withRudderTyperContext(),
        );
      }
    };
  },
});
