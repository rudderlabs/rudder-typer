(function (f) {
  if (typeof exports === 'object' && typeof module !== 'undefined') {
    module.exports = f();
  } else if (typeof define === 'function' && define.amd) {
    define([], f);
  } else {
    var g;
    if (typeof window !== 'undefined') {
      g = window;
    } else if (typeof global !== 'undefined') {
      g = global;
    } else if (typeof self !== 'undefined') {
      g = self;
    } else {
      g = this;
    }
    g.rudderTyper = f();
  }
})(function () {
  var define, module, exports;
  return (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            var c = 'function' == typeof require && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            var a = new Error("Cannot find module '" + i + "'");
            throw ((a.code = 'MODULE_NOT_FOUND'), a);
          }
          var p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              var n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t,
          );
        }
        return n[i].exports;
      }
      for (var u = 'function' == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
      return o;
    }
    return r;
  })()(
    {
      1: [
        function (require, module, exports) {
          'use strict';
          /**
           * This client was automatically generated by RudderTyper. ** Do Not Edit **
           */
          var __assign =
            (this && this.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          exports.RudderTyperAnalytics =
            exports.group =
            exports.identify =
            exports.page =
            exports.sampleEvent1 =
            exports.setRudderTyperOptions =
              void 0;
          var analytics = function () {
            return window.rudderanalytics;
          };
          /**
           * Updates the run-time configuration of this RudderTyper client.
           *
           * @param {RudderTyperOptions} options - the options to upsert
           *
           * @typedef {Object} RudderTyperOptions
           * @property {Rudder.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
           * 		calls are forwarded on to. Defaults to window.analytics.
           * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
           * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
           * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
           * 		will be logged to stderr.
           */
          function setRudderTyperOptions(options) {
            analytics = options.analytics
              ? function () {
                  return options.analytics || window.rudderanalytics;
                }
              : analytics;
          }
          exports.setRudderTyperOptions = setRudderTyperOptions;
          /**
           * Helper to attach metadata on RudderTyper to outbound requests.
           * This is used for attribution and debugging by the RudderStack team.
           */
          function withRudderTyperContext(message) {
            if (message === void 0) {
              message = {};
            }
            return __assign(__assign({}, message), {
              context: __assign(__assign({}, message.context || {}), {
                ruddertyper: {
                  sdk: 'analytics.js',
                  language: 'typescript',
                  rudderTyperVersion: '1.2.0',
                  trackingPlanId: 'tp_2kKI0i514th5OEuYi5AdsRwNlXC',
                  trackingPlanVersion: 3,
                },
              }),
            });
          }
          /**
           * @typedef SampleEvent1
           * @property {any | null} [Sample property 1] - Sample property 1
           */
          /**
           * @typedef Page
           * @property {any | null} [Sample property 1] -
           */
          /**
           * @typedef Group
           * @property {any | null} [Sample property 1] -
           */
          /**
           * @typedef Identify
           * @property {any | null} [Sample property 1] -
           */
          /**
           * Sample event 1
           *
           * @param {SampleEvent1} [props] - The analytics properties that will be sent to RudderStack.
           * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
           * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
           */
          function sampleEvent1(props, options, callback) {
            var a = analytics();
            if (a) {
              a.track('Sample event 1', props || {}, withRudderTyperContext(options), callback);
            }
          }
          exports.sampleEvent1 = sampleEvent1;
          function page(
            categoryOrProps,
            nameOrPropsOrOptions,
            propsOrOptionsOrCallback,
            optionsOrCallback,
            callback,
          ) {
            var a = analytics();
            if (a) {
              if (typeof categoryOrProps === 'string' && typeof nameOrPropsOrOptions === 'string') {
                // Overload (category: string, name: string, props?: Page, options?: ApiOptions, callback?: apiCallback)
                a.page(
                  categoryOrProps,
                  'page',
                  propsOrOptionsOrCallback || {},
                  withRudderTyperContext(optionsOrCallback),
                  callback,
                );
              } else if (typeof categoryOrProps === 'string') {
                // Overload (name: string, props?: Page, options?: ApiOptions, callback?: apiCallback)
                a.page(
                  'page',
                  nameOrPropsOrOptions || {},
                  withRudderTyperContext(propsOrOptionsOrCallback),
                  optionsOrCallback,
                );
              } else {
                // Overload (props?: Page, options?: ApiOptions, callback?: apiCallback)
                a.page(
                  categoryOrProps || {},
                  withRudderTyperContext(nameOrPropsOrOptions),
                  propsOrOptionsOrCallback,
                );
              }
            }
          }
          exports.page = page;
          function identify(userIdOrTraits, traitsOrOptions, optionsOrCallback, callback) {
            var a = analytics();
            if (a) {
              var userId = typeof userIdOrTraits === 'string' ? userIdOrTraits : undefined;
              var traits = typeof userIdOrTraits === 'string' ? traitsOrOptions : userIdOrTraits;
              var options =
                typeof userIdOrTraits === 'string' ? optionsOrCallback : traitsOrOptions;
              var cb = typeof userIdOrTraits === 'string' ? callback : optionsOrCallback;
              a.identify(userId, traits || {}, withRudderTyperContext(options), cb);
            }
          }
          exports.identify = identify;
          function group(groupIdOrTraits, traitsOrOptions, optionsOrCallback, callback) {
            var a = analytics();
            if (a) {
              if (typeof groupIdOrTraits === 'string') {
                var groupId = groupIdOrTraits;
                var traits = traitsOrOptions || {};
                var options = optionsOrCallback;
                a.group(groupId, traits, withRudderTyperContext(options), callback);
              } else {
                var traits = groupIdOrTraits || {};
                var options = traitsOrOptions;
                var cb = optionsOrCallback;
                a.group(traits, withRudderTyperContext(options), cb);
              }
            }
          }
          exports.group = group;
          var clientAPI = {
            /**
             * Updates the run-time configuration of this RudderTyper client.
             *
             * @param {RudderTyperOptions} options - the options to upsert
             *
             * @typedef {Object} RudderTyperOptions
             * @property {Rudder.AnalyticsJS} [analytics] - Underlying analytics instance where analytics
             * 		calls are forwarded on to. Defaults to window.analytics.
             * @property {Function} [onViolation] - Handler fired when if an event does not match its spec. This handler does not fire in
             * 		production mode, because it requires inlining the full JSON Schema spec for each event in your Tracking Plan. By default,
             * 		it will throw errors if NODE_ENV="test" so that tests will fail if a message does not match the spec. Otherwise, errors
             * 		will be logged to stderr.
             */
            setRudderTyperOptions: setRudderTyperOptions,
            /**
             * Sample event 1
             *
             * @param {SampleEvent1} [props] - The analytics properties that will be sent to RudderStack.
             * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
             * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
             */
            sampleEvent1: sampleEvent1,
            /**
             * Sample Page event
             *
             * @param {string} [category] - The category of the page.
             * @param {string} [name] - The name of the page.
             * @param {Page} [props] - The analytics properties that will be sent to RudderStack.
             * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
             * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
             */
            page: page,
            /**
             * Sample Identify event
             *
             * @param {string} [userId] - The user ID of the user.
             * @param {Identify} [traits] - The analytics traits that will be sent to RudderStack.
             * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
             * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
             */
            identify: identify,
            /**
             * Sample Group event
             *
             * @param {string} [groupId] - The group ID of the group.
             * @param {Group} [traits] - The analytics traits that will be sent to RudderStack.
             * @param {Object} [options] - A dictionary of options. For example, enable or disable specific destinations for the call.
             * @param {Function} [callback] - An optional callback called after a short timeout after the analytics call is fired.
             */
            group: group,
          };
          exports.RudderTyperAnalytics = new Proxy(clientAPI, {
            get: function (target, method) {
              if (typeof method === 'string' && Object.keys(target).includes(method)) {
                return target[method];
              }
              return function () {
                var a = analytics();
                if (a) {
                  a.track(
                    'Unknown Analytics Call Fired',
                    {
                      method: method,
                    },
                    withRudderTyperContext(),
                  );
                }
              };
            },
          });
        },
        {},
      ],
    },
    {},
    [1],
  )(1);
});
