/**
 * {{autogeneratedFileWarning}}
 */

{{#if isDevelopment}}
/**
 * Ajv is a peer dependency for development builds. It's used to apply run-time validation
 * to message payloads before passing them on to the underlying analytics instance.
 *
 * Note that the production bundle does not depend on Ajv.
 * 
 * You can install it with: `npm install --save-dev ajv`.
 *
 * In order to support run-time validation of draft-04 JSON Schema we are using `ajv-draft-04`.
 * You can install it with: `npm install --save-dev ajv-draft-04`.
 *
 */
import Ajv, { ErrorObject } from 'ajv'
import AjvDraft4 from 'ajv-draft-04'
{{/if}}
import * as Rudder from './rudder'
{{#if isBrowser}}
type apiCallback = (data?: any) => void;
{{else}}
import { apiObject, apiCallback } from '@rudderstack/rudder-sdk-node'
{{/if}}

{{#each objects}}
{{#if description}}
/**
 * {{description}}
 */
{{/if}}
export interface {{name}} {{#unless ../isBrowser}} extends apiObject {{/unless}} {
	{{#each properties}}
	{{#if description}}
	/**
	 * {{description}}
	 */
	{{/if}}
	'{{name}}'{{#unless isRequired}}?{{/unless}}: {{type}}
	{{/each}}
}
{{/each}}

export type ViolationHandler = (
	message: {{#if isBrowser}}Record<string, any>{{else}}Rudder.TrackMessage<Record<string, any>>{{/if}},
	{{!-- Swap the type definitions here so we don't want depend on ajv in production just for this type definition. --}}
	violations: {{#if isDevelopment}}ErrorObject{{else}}any{{/if}}[]
) => void

{{#if isDevelopment}}
/**
 * The default handler that is fired if none is supplied with setRudderTyperOptions.
 {{#if isBrowser}}
 * This handler will log a warning message to the console.
 {{else}}
 * If NODE_ENV="test", this handler will throw an error. Otherwise, it will log
 * a warning message to the console.
 {{/if}}
 */
export const defaultValidationErrorHandler: ViolationHandler = (message, violations) => {
	const msg = JSON.stringify({
		type: 'RudderTyper JSON Schema Validation Error',
		description:
			`You made an analytics call (${message.event}) using RudderTyper that doesn't match the ` +
			'Tracking Plan spec.',
		errors: violations,
	}, undefined, 2)

	{{#unless isBrowser}}
	if (process.env.NODE_ENV === 'test') {
		throw new Error(msg)
	}
	{{/unless}}
	console.warn(msg)
}

let onViolation = defaultValidationErrorHandler
{{/if}}

{{#unless isBrowser}}
const missingAnalyticsNodeError = new Error(`You must set an analytics-node instance:

>	const RudderAnalytics = require('@rudderstack/rudder-sdk-node');
>	const { setRudderTyperOptions } = require('./analytics')
>
>	const analytics = new RudderAnalytics(WRITE_KEY, DATA_PLANE_URL/v1/batch)
>	setRudderTyperOptions({
>		analytics: analytics,
>	})

For more information on analytics-node, see: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#installing-the-rudderstack-node-js-sdk
`)
{{/unless}}

{{!-- We use a closure so we can lazy-resolve window.rudderanalytics in browser environments. --}}
let analytics: () => ({{#if isBrowser}}any{{else}}Rudder.AnalyticsNode{{/if}} | undefined) = () => {
	{{#if isBrowser}}
	return window.rudderanalytics
	{{else}}
	throw missingAnalyticsNodeError
	{{/if}}
}

/** Options to customize the runtime behavior of a RudderTyper client. */
export interface RudderTyperOptions {
	/**
	 * Underlying analytics instance where analytics calls are forwarded on to.
	 {{#if isBrowser}}
	 * Defaults to window.rudderanalytics.
	 {{/if}}
	 */
	analytics{{#if isBrowser}}?{{/if}}: {{#if isBrowser}}any{{else}}Rudder.AnalyticsNode{{/if}}
	/**
	 * Handler fired when if an event does not match its spec. This handler
	 * does not fire in production mode, because it requires inlining the full
	 * JSON Schema spec for each event in your Tracking Plan.
	 *
	 * By default, it will throw errors if NODE_ENV = "test" so that tests will fail
	 * if a message does not match the spec. Otherwise, errors will be logged to stderr.
	 */
	onViolation?: ViolationHandler
}

{{> setRudderTyperOptionsDocumentation}}
export function setRudderTyperOptions(options: RudderTyperOptions) {
	analytics = options.analytics ? () => options.analytics{{#if isBrowser}} || window.rudderanalytics{{/if}} : analytics
	{{#if isDevelopment}}
	onViolation = options.onViolation || onViolation
	{{/if}}
}

{{#if isDevelopment}}
/**
	* Validates a message against a JSON Schema using Ajv. If the message
	* is invalid, the `onViolation` handler will be called.
	*/
async function validateAgainstSchema(
	message: {{#if isBrowser}}Record<string, any>{{else}}Rudder.TrackMessage<Record<string, any>>{{/if}},
	schema: Rudder.Schema
) {
	let ajv;
	if (schema['$schema'] && schema['$schema'].includes('draft-04')) {
		ajv = new AjvDraft4({
			allErrors: true,
			verbose: true
		})
	} else {
		ajv = new Ajv({
			allErrors: true,
			verbose: true
		})
		const schemaDraft06 =await import('ajv/lib/refs/json-schema-draft-06.json');
		ajv.addMetaSchema(schemaDraft06);
	}
	if (!ajv.validate(schema, message) && ajv.errors) {
		onViolation(message, ajv.errors)
	}
}
{{/if}}

/**
 * Helper to attach metadata on RudderTyper to outbound requests.
 * This is used for attribution and debugging by the RudderStack team.
 */
function withRudderTyperContext{{#unless isBrowser}}<P, T extends Rudder.TrackMessage<P>>{{/unless}}(message: {{#if isBrowser}}Rudder.Options = {}{{else}}T{{/if}}): {{#if isBrowser}}Rudder.Options{{else}}T{{/if}} {
	return {
		...message,
		context: {
			...(message.context || {}),
			ruddertyper: {
				sdk: '{{sdk}}',
				language: '{{language}}',
				rudderTyperVersion: '{{rudderTyperVersion}}',
				trackingPlanId: '{{trackingPlanId}}',
				trackingPlanVersion: {{trackingPlanVersion}},
            },
		},
	}
}

{{#unless isBrowser}}
/**
 * A message payload for an analytics-node `.track()` call.
 * See: https://docs.rudderstack.com/stream-sources/rudderstack-sdk-integration-guides/rudderstack-node-sdk#track
 *
 * @typedef TrackMessage<PropertiesType>
 * @property {string | number} [userId] - The ID for this user in your database.
 * @property {string | number} [anonymousId] - An ID to associated with the user when you don't know who they are.
 * @property {PropertiesType} [properties] - A dictionary of properties for the event.
 * @property {Date} [timestamp] - A Javascript date object representing when the track took place. If the track
 * 		just happened, leave it out and we'll use the server's time. If you're importing data from the past make
 * 		sure you to send a timestamp.
 * @template PropertiesType
 */
{{/unless}}

{{#each objects}}
/**
 {{#if description}}
 * {{description}}
 {{/if}}
 * @typedef {{name}}
 {{#each properties}}
	{{!-- Note: this uses whitespace control to "escape" the outer curly braces. --}}
	{{!-- Note: The backticks enable JSDoc to parse names with spaces (without resorting to square brackets). --}}
	{{!-- Temporary removed backticks around required names below because of typescript compiler + JSDoc error. Will investigate. --}}
 * @property { {{~type~}} } {{#if isRequired}}{{name}}{{else}}[{{name}}]{{/if}} - {{description}}
 {{/each}}
 */
{{/each}}

{{#each tracks}}
{{> functionDocumentation isBrowser=../isBrowser }}
{{#if ../isBrowser}}
export function {{functionName}}(
	props{{#if isPropertiesOptional}}?{{/if}}: {{propertiesType}},
	options?: Rudder.Options,
	callback?: apiCallback
): void {
	const a = analytics()
	{{#if ../isDevelopment}}
	const schema = {{rawJSONSchema}}
	const message = {
		event: '{{rawEventName}}',
		properties: props || {},
		options,
	}
	validateAgainstSchema(message, schema).then(()=>{
		if (a) {
			a.track(
				'{{rawEventName}}',
				props || {},
				withRudderTyperContext(options),
				callback
			)
		}
	})
	{{else}}
	if (a) {
		a.track(
			'{{rawEventName}}',
			props || {},
			withRudderTyperContext(options),
			callback
		)
	}
	{{/if}}
}
{{else}}
export function {{functionName}}(
	message: Rudder.TrackMessage<{{propertiesType}}>,
	callback?: apiCallback
): void {
	const msg = withRudderTyperContext({
		properties: {},
		...message,
		event: '{{rawEventName}}'
	})
	const a = analytics()
	{{#if ../isDevelopment}}
	const schema = {{rawJSONSchema}}	
	validateAgainstSchema(msg, schema).then(()=>{
		if (a) {
			a.track(msg, callback)
		} else {
			throw missingAnalyticsNodeError
		}
	})
	{{else}}
	if (a) {
		a.track(msg, callback)
	} else {
		throw missingAnalyticsNodeError
	}
	{{/if}}

}
{{/if}}
{{/each}}

{{#if useProxy}}
const clientAPI = {
	{{> setRudderTyperOptionsDocumentation}}
	setRudderTyperOptions,
	{{#each tracks}}
	{{> functionDocumentation isBrowser=../isBrowser }}
	{{functionName}},
	{{/each}}
}

export const RudderTyperAnalytics = new Proxy<typeof clientAPI>(clientAPI, {
	get(target, method) {
		if (typeof method === 'string' && Object.keys(target).includes(method)) {
			return target[method as keyof typeof clientAPI]
		}

		return () => {
			{{#if isDevelopment}}
			console.warn(`⚠️  You made an analytics call (${String(method)}) that can't be found. Either:
    a) Re-generate your ruddertyper client: \`npx rudder-typer\`
    b) Add it to your Tracking Plan: {{trackingPlanURL}}`)
			{{/if}}
			const a = analytics()
			if (a) {
				{{#if isBrowser}}
				a.track('Unknown Analytics Call Fired',
					{
						method,
					},
					withRudderTyperContext()
				)
				{{else}}
				a.track(withRudderTyperContext({
					event: 'Unknown Analytics Call Fired',
					properties: {
						method : [method as string],
					},
					userId: 'ruddertyper'
				}))
				{{/if}}
			}
		}
	}
})
{{/if}}